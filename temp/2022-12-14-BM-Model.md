---
title: 转角石墨烯BM模型推导和数值计算(Twisted bilayer graphene BM model)
tags: Twist 
layout: article
license: true
toc: true
key: a20211214
pageview: true
# cover: /assets/images/GroupTheory/cube_symmetry.jpg
header:
  theme: dark
  background: 'linear-gradient(135deg, rgb(34, 139, 87), rgb(139, 34, 139))'
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
aside:
    toc: true
sitemap: true
mathjax: true
author: YuXuan
show_author_profile: true
---
转角石墨烯成为研究热点受到了广泛的关注，最近看到的文献涉及到了相应的内容，虽然不是在研究转角石墨烯的强关联性质，但是还是需要了解如何对转角石墨烯构建有效模型，并通过数值的方式计算能带。这里就整理一下自己在学习twisted bilayer graphene(TBG)时候的笔记，并通过代码来复现Bistritzer-MacDonald模型能带。
{:.info}
<!--more-->
# 代码
```julia
@everywhere using SharedArrays, LinearAlgebra,Distributed,DelimitedFiles,Printf,Arpack
#-----------------------------------------
@everywhere function HSLG(vf::Float64,qx::Float64,qy::Float64,kk::Int64,jj::Int64,d::Float64,theta::Float64)
    b1m = 8 * pi * sin(abs(theta))/(3 * d) * [1/2,-sqrt(3)/2]
    b2m = 8 * pi * sin(abs(theta))/(3 * d) * [1/2,sqrt(3)/2]
    kx = qx - kk * b1m[1] - jj * b2m[1]
    ky = qy - kk * b1m[2] - jj * b2m[2]
    h =  -vf * sqrt(kx^2 + ky^2) * [0 exp(im * (angle(kx + im * ky) - theta)); exp(-im * (angle(kx + im * ky) - theta)) 0]
    return h
end
#-----------------------------------------------------
@everywhere function band(ang::Float64)
    # ang is twist angle
    d::Float64 = 1.42  # nearest c-c bond length
    vf::Float64 = 5.944  # Fermi velocity
    phi::Float64 = 2 * pi/3
    # theta::Float64 = 1.05/180 * pi
    theta::Float64 = ang/180 * pi
    w1::Float64 = 0.110
    tr::Int64 = 3 # truncation
    s::Int64 = (2 * tr + 1)
    N::Int64 = s^2
    Tb = w1 * ones(2,2) # 对角单位矩阵
    Ttr = w1 * [exp(-im * phi) 1; exp(im * phi) exp(-im * phi)]
    Ttl = w1 * [exp(im * phi) 1; exp(-im * phi) exp(im * phi)]
    qb = 8 * pi * sin(theta/2)/(3 * sqrt(3) * d) * [0, -1]
    qtr = 8 * pi * sin(theta/2)/(3 * sqrt(3) * d) * [sqrt(3)/2,1/2]
    qtl = 8 * pi * sin(theta/2)/(3 * sqrt(3) * d) * [-sqrt(3)/2,1/2]
    # geaphene具有A,B子晶格
    H = zeros(ComplexF64,2 * 2 * N,2 * 2 * N) # Hamiltonian
    N1y = collect(range(-1,0,58)) .* norm(qb)
    N1x = 0 * N1y
    N2y = collect(range(0,1,58)) .* norm(qb)
    N2x = 0 * N2y
    N3y = collect(range(1,-1/2,100)) .* norm(qb)
    N3x = (-N3y .+ norm(qb))/sqrt(3)
    N4y = collect(range(-1/2,-1,58)) .* norm(qb)
    N4x = (N4y .+ norm(qb)) * sqrt(3)
    Nx = append!(N1x,N2x,N3x,N4x)
    Ny = append!(N1y,N2y,N3y,N4y) # k-path : A - B - C - D - A
    # band = zeros(length(Nx),4 * N)
    band = SharedArray(zeros(Float64,length(Nx),4 * N)) 
    #-----------------------------------------
    @sync @distributed for ii in eachindex(Nx)
        kx = Nx[ii]
        ky = Ny[ii]
        c = 1 
        Hdiag = zeros(ComplexF64,2 * 2 * N,2 * 2 * N) # diagonal element
        for kk in -tr:tr,jj = -tr:tr
            temp = zeros(Float64,2 * N,2 * N)
            temp[c,c] = 1
            Hdiag += kron(temp,HSLG(vf,kx,ky,kk,jj,d,theta/2)) # 1st layer, red points
            c += 1
        end
        for kk = -tr:tr,jj = -tr:tr
            temp = zeros(Float64,2 * N,2 * N)
            temp[c,c] = 1
            Hdiag += kron(temp,HSLG(vf,kx - qb[1],ky - qb[2],kk,jj,d,-theta/2)) # 2nd layer, blue points
            c += 1
        end
        Hoff1 = zeros(ComplexF64,2 * N,2 * N)  # off-diagonal element
        Hoff2 = zeros(ComplexF64,2 * N,2 * N)
        for k2 in -tr:tr,j2 in -tr:tr,k1 in -tr:tr,j1 in -tr:tr
            if k1 == k2 &&  j1 == j2
                off1 = zeros(ComplexF64,N,N)
                off1[(k1 + tr) * s + j1 + tr + 1,(k2 + tr) * s + j2 + tr + 1] = 1
                Hoff1 +=  kron(off1,Tb)
                off2 = zeros(ComplexF64,N,N)
                off2[(k2 + tr) * s + j2 + tr + 1,(k1 + tr) * s + j1 + tr + 1] = 1
                Hoff2 += kron(off2,Tb')
            elseif k1 == k2 && j1  + 1 == j2
                off1 = zeros(ComplexF64,N,N)
                off1[(k1 + tr) * s + j1 + tr + 1,(k2 + tr) * s + j2 + tr + 1] = 1
                Hoff1 += kron(off1,Ttr)
                off2 = zeros(ComplexF64,N,N)
                off2[(k2 + tr) * s + j2 + tr + 1,(k1 + tr) * s + j1 + tr + 1] = 1
                Hoff2 += kron(off2,Ttr')
            elseif k1 - 1 == k2 && j1 == j2
                off1 = zeros(ComplexF64,N,N)
                off1[(k1 + tr) * s + j1 + tr + 1,(k2 + tr) * s + j2 + tr + 1] = 1
                Hoff1 += kron(off1,Ttl)
                off2 = zeros(ComplexF64,N,N)
                off2[(k2 + tr) * s + j2 + tr + 1,(k1 + tr) * s + j1 + tr + 1] = 1
                Hoff2 += kron(off2,Ttl')
            end
        end
        Hoff = kron([0 1;0 0],Hoff1) + kron([0 0;1 0],Hoff2)
        H = Hdiag + Hoff
        val= eigvals(H)
        band[ii,:] = sort(val)
    end
    temp = (a->(@sprintf "%3.2f" a)).(ang)
    fn1 = "band-theta=" * temp * ".dat"
    f1 = open(fn1,"w")
    x0 = (a->(@sprintf "%15.8f" a)).(1:length(Nx))
    y0 = (a->(@sprintf "%15.8f" a)).(band)
    writedlm(f1,[x0 y0],"\t")
    close(f1)    
end
#----------------------------------------------------------
@time band(1.05)
@time band(5.0)
@time band(0.5)
```

![png](/assets/images/BM-model/band-theta=0.50.png)

![png](/assets/images/BM-model/band-theta=1.05.png)

![png](/assets/images/BM-model/band-theta=5.00.png)

## 绘图程序
```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
import os
config = {
"font.size": 30,
"mathtext.fontset":'stix',
"font.serif": ['SimSun'],
}
rcParams.update(config) # Latex 字体设置
#---------------------------------------------------------
def scatterplot1(cont):
    dataname = "band-theta=" + format(cont,'.2f') + ".dat"
    # dataname = "band-theta=1.05.dat"
    tit = "Twist angele is " + format(cont,'.2f') + "$^\degree$"
    # da1 = "did-short.dat"
    picname = os.path.splitext(dataname)[0] + ".png"
    os.chdir(os.getcwd())# 确定用户执行路径
    x0 = np.loadtxt(dataname)
    plt.figure(figsize=(10,10))
    plt.plot(x0[:,0], x0[:,1:-1], c = 'blue')
    x0min = np.min(x0[:,0])
    x0max = np.max(x0[:,0])
    # y0min = np.min(x0[:,1])
    # y0max = np.max(x0[:,1])
    font2 = {'family': 'Times New Roman',
             'weight': 'normal',
             'size': 25,
             }
    plt.xlim(x0min,x0max)
    plt.ylim(-0.15,0.15)
    # plt.xlabel(r'$\phi_{R-L}/\pi$',font2)
    plt.ylabel("$E$",font2)
    plt.title(tit,font2)
    # plt.yticks(fontproperties='Times New Roman', size = 15)
    plt.xticks(fontproperties='Times New Roman', size = 15)
    # plt.xticks([0,1,2],fontproperties='Times New Roman', size = 25)
    # plt.yticks([-0.25,-0.15,0,0.15,0.25],fontproperties='Times New Roman', size = 25)
    plt.yticks([-0.15,0,0.15],fontproperties='Times New Roman', size = 25)
    plt.tick_params(axis='x',width = 2,length = 10)
    plt.tick_params(axis='y',width = 2,length = 10)
    ax = plt.gca()
    ax.spines["bottom"].set_linewidth(1.5)
    ax.spines["left"].set_linewidth(1.5) 
    ax.spines["right"].set_linewidth(1.5)
    ax.spines["top"].set_linewidth(1.5)
    plt.savefig(picname, dpi = 100, bbox_inches = 'tight',transparent = True)
    plt.close()
#---------------------------------------------------------
if __name__=="__main__":
    scatterplot1(1.05)
    scatterplot1(0.5)
    scatterplot1(5)
```

# 参考
- [转角双层石墨烯(Twisted Bilayer Graphene): Bistritzer-MacDonald model](https://zhuanlan.zhihu.com/p/442528883)
- [Twisted Bilayer Graphene: Low‐Energy Physics, Electronic and Optical Properties](https://onlinelibrary.wiley.com/doi/10.1002/9781119468455.ch44)
- [Twisted bilayer graphene — electronic and optical properties](https://fenix.tecnico.ulisboa.pt/downloadFile/1970719973966349/Thesis.pdf)

